<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="color-scheme" content="dark only" />
  <meta name="theme-color" content="#0b0d10" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <title>ONONO — stealth</title>
  <meta name="description" content="ONONO — a restrained thesis about intelligence in a complex, shifting world. Stealth mode. Innovation-First." />
  <style>
    /* ====== Design Tokens (Stealth Monolith) ====== */
    :root{
      --bg:#0b0d10;          /* near-black */
      --bg-2:#101317;        /* deep slate for section contrast */
      --text:#e6e8eb;        /* soft white */
      --muted:#9DB2BF;       /* subtle text/accent */
      --edge:#171b20;        /* hairline divider */
      --accent-1:#27374D;    /* provided palette */
      --accent-2:#526D82;
      --accent-3:#9DB2BF;
      --accent-4:#DDE6ED;

      --maxw:152ch; 
      --pad:clamp(20px, 4vw, 48px);
      --lh:1.5;
    }

    /* ====== Base ====== */
    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font-family: -apple-system,BlinkMacSystemFont,"Segoe UI",Inter,Roboto,"Helvetica Neue",Arial,"Noto Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji";
      line-height:var(--lh);
      -webkit-font-smoothing:antialiased;
      text-rendering:optimizeLegibility;
      transition: background 1.6s ease, color .8s ease;
    }
    body[data-phase="intro"]{ overflow:hidden; }
    body::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        radial-gradient(60vw 60vw at 20% 15%, color-mix(in oklab, var(--accent-3) 8%, transparent) 0%, transparent 68%),
        radial-gradient(80vw 80vw at 80% 75%, color-mix(in oklab, var(--accent-1) 12%, transparent) 0%, transparent 80%),
        linear-gradient(160deg, transparent 0 40%, rgba(12,15,19,.5) 55%, transparent 75%);
      opacity:.32;
      mix-blend-mode:screen;
    }
    a{ color:inherit; text-decoration:none; }
    a:hover{ text-decoration:underline; text-decoration-thickness:1px; }
    :focus-visible{ outline:2px solid var(--accent-3); outline-offset:3px; border-radius:4px; }

    .container{ max-width: min(1100px, 92vw); margin:0 auto; padding-inline:var(--pad); }
    .stack{ display:flex; flex-direction:column; gap:clamp(14px, 2.2vw, 20px); }
    .muted{ color:var(--muted); }
    .hairline{ border-top:1px solid var(--edge); }
    .kicker{ letter-spacing:.14em; text-transform:uppercase; font-size:.78rem; color:var(--muted); }
    .mono{ font-variant-numeric: tabular-nums; }

    /* ====== Header / Nav ====== */
    header{
      position:sticky; top:0; z-index:10;
      backdrop-filter: blur(6px);
      background: color-mix(in oklab, var(--bg) 85%, transparent);
      border-bottom:1px solid var(--edge);
      transition: transform .9s ease .35s, opacity .9s ease .35s;
    }
    body[data-phase="intro"] header{ opacity:0; transform: translateY(-30px); }
    .nav{ display:flex; align-items:center; justify-content:space-between; padding:16px var(--pad); }
    .brand{ font-weight:600; letter-spacing:.02em; }
    .nav a{ opacity:.86; }
    .nav a:hover{ opacity:1; text-decoration:none; }
    .nav-links{ display:flex; gap:20px; align-items:center; }

    /* ====== Hero ====== */
    .hero{
      position:relative; isolation:isolate;
      min-height:100vh;
      display:flex;
      align-items:center;
      padding-block: clamp(96px, 20vh, 160px);
      overflow:hidden;
      transition: transform 1.1s ease .45s, opacity 1.1s ease .45s;
    }
    body[data-phase="intro"] .hero{ opacity:0; transform: translateY(40px); }
    .hero .center{ position:relative; }
    .hero h1{
      font-size:clamp(2rem, 6vw, 4rem);
      line-height:1.06;
      letter-spacing:-0.01em;
      margin:0;
    }
    .hero h1 br{ display:block; }
    .hero-word{
      position:relative;
      display:inline-block;
      color:#9db2bf;
      letter-spacing:0.12em;
      font-weight:600;
      text-align:left;
      white-space:nowrap;
    }
    .hero-word::after{
      content:"CONSCIOUSNESS";
      display:block;
      height:0;
      overflow:hidden;
      visibility:hidden;
      letter-spacing:inherit;
      font-weight:inherit;
    }
    @media (max-width: 639px){
      .hero-word{ white-space:normal; }
      .hero-word::after{ content:none; }
    }
    .hero-word .word-static{
      display:inline-block;
      transition:opacity .36s ease;
    }
    .hero-word .word-static.is-fading-out{
      opacity:0;
    }
    .hero-word .word-static.is-fading-in{
      opacity:1;
    }
    .hero p{
      max-width: min(52rem, 100%);
      font-size: clamp(1rem, 1.6vw, 1.125rem);
      color: var(--muted);
    }
    .hero-motto{
      display:flex;
      flex-direction:column;
      gap:4px;
      margin-top: clamp(10px, 2vw, 18px);
      font-size:clamp(1rem, 1.4vw, 1.125rem);
      color:var(--muted);
    }
    .hero-motto-line{
      display:inline-block;
      transition:opacity .36s ease;
    }
    .hero-motto-line.is-fading-out{ opacity:0; }
    .hero-motto-line.is-fading-in{ opacity:1; }
    .cta{
      display:flex; gap:10px; flex-wrap:wrap; margin-top:10px;
    }
    .btn{
      display:inline-flex; align-items:center; justify-content:center;
      padding:10px 14px; border-radius:10px;
      border:1px solid var(--edge);
      background: linear-gradient(to bottom, #0c0f13, #0a0c10);
      text-decoration:none; opacity:.96;
      transition: transform .2s ease, border-color .2s ease, opacity .2s ease;
    }
    .btn:hover{ transform: translateY(-1px); opacity:1; border-color: color-mix(in oklab, var(--accent-3) 30%, var(--edge)); text-decoration:none; }
    .btn-ghost{ background: transparent; }
    .btn-accent{
      border-color: color-mix(in oklab, var(--accent-2) 40%, var(--edge));
      background: linear-gradient(180deg, color-mix(in oklab, var(--accent-1) 10%, #0a0c10), #0a0c10);
    }

    /* Subtle animated backdrop */
    .hero::before{
      content:""; position:absolute; inset:-40vmax; z-index:-1;
      background:
        radial-gradient(40vmax 40vmax at 15% 20%, color-mix(in oklab, var(--accent-1) 28%, transparent) 0%, transparent 60%),
        radial-gradient(36vmax 36vmax at 85% 80%, color-mix(in oklab, var(--accent-2) 22%, transparent) 0%, transparent 70%),
        radial-gradient(50vmax 50vmax at 60% 10%, color-mix(in oklab, var(--accent-3) 12%, transparent) 0%, transparent 75%);
      filter: blur(40px) saturate(120%);
      animation: drift 60s linear infinite;
      opacity:.45;
    }
    @keyframes drift{
      0%{ transform: translate3d(-6%, -4%, 0) rotate(0deg); }
      50%{ transform: translate3d(6%, 4%, 0) rotate(180deg); }
      100%{ transform: translate3d(-6%, -4%, 0) rotate(360deg); }
    }
    @media (prefers-reduced-motion: reduce){
      .hero::before{ animation:none; }
    }

    .sigil{
      position:absolute;
      right: clamp(12px, 6vw, 80px);
      bottom: clamp(-10px, -2vw, 18px);
      display:flex;
      align-items:center;
      gap:10px;
      opacity:.6;
      filter: blur(.2px);
      transition: opacity .3s ease;
      pointer-events:auto;
    }
    .sigil:hover{ opacity:.9; }
    .sigil-ring{
      width: clamp(40px, 10vw, 72px);
      aspect-ratio:1;
      border-radius:50%;
      border:1px solid color-mix(in oklab, var(--accent-3) 40%, transparent);
      box-shadow:0 0 22px rgba(82,109,130,.28) inset;
      cursor:pointer;
      transition: transform .3s ease, box-shadow .3s ease, border-color .3s ease;
    }
    .sigil-ring:active{
      transform: scale(.95);
      box-shadow:0 0 26px rgba(82,109,130,.45) inset;
    }
    .sigil-glyph{
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      letter-spacing:.4em;
      color: color-mix(in oklab, var(--accent-4) 40%, var(--muted));
    }
    .sigil[data-boosting="true"] .sigil-ring{
      border-color: color-mix(in oklab, var(--accent-3) 65%, transparent);
      box-shadow:0 0 30px rgba(157,178,191,.4) inset, 0 0 18px rgba(157,178,191,.18);
    }
    @media (max-width: 680px){
      .sigil{
        right: clamp(14px, 8vw, 36px);
        bottom: clamp(14px, 10vw, 15px);
        opacity:.72;
      }
      .sigil-ring{
        width: clamp(48px, 18vw, 66px);
      }
      .sigil-glyph{
        font-size: clamp(1rem, 4vw, 1.4rem);
      }
    }

    /* ====== Sections ====== */
    section{ padding-block: clamp(56px, 10vh, 96px); }
    .lead{ font-size: clamp(1.05rem, 1.7vw, 1.22rem); color:var(--muted); }
    .thesis-points{ margin:0; padding-left:1.2rem; max-width:var(--maxw); }
    .thesis-points li{ margin: .4rem 0; }
    .panel{
      background: linear-gradient(180deg, #0c0f13, #0a0c10);
      border: 1px solid var(--edge);
      border-radius: 14px;
      padding: clamp(16px, 4vw, 24px);
      box-shadow: 0 20px 40px rgba(0,0,0,.35);
      position:relative;
      overflow:hidden;
    }
    .panel::after{
      content:"";
      position:absolute;
      inset:1px;
      border-radius: inherit;
      border:1px solid rgba(221,230,237,.06);
      pointer-events:none;
    }

    /* ====== Footer ====== */
    footer{ border-top:1px solid var(--edge); padding:20px var(--pad) 40px; color:var(--muted); }
    .footgrid{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between; }
    .small{ font-size:.88rem; }

    /* ====== Utils ====== */
    .center{ display:flex; flex-direction:column; gap:18px; align-items:flex-start; }
    .spacer{ height: clamp(28px, 4vw, 40px); }
    .caps{ text-transform:uppercase; letter-spacing:.12em; font-size:.78rem; color:var(--muted); }
    .divider{ height:1px; background:var(--edge); margin-block: 24px; }
    .nowrap{ white-space:nowrap; }
    .muted-hr{ border:none; border-top:1px solid var(--edge); margin: 14px 0 0; opacity:.7; }
    .skip{
      position:absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden;
    }
    .skip:focus{ position:fixed; left:16px; top:12px; width:auto; height:auto; padding:8px 12px; background:#000; border:1px solid var(--edge); border-radius:10px; z-index:999; }

    .scroll-hint{
      position:fixed;
      right:clamp(14px, 4vw, 32px);
      bottom:clamp(14px, 4vw, 32px);
      display:flex;
      align-items:center;
      gap:8px;
      padding:8px 12px;
      border:1px solid var(--edge);
      border-radius:999px;
      background: color-mix(in oklab, var(--bg) 80%, transparent);
      color:var(--muted);
      font-size:.75rem;
      letter-spacing:.12em;
      text-transform:uppercase;
      opacity:.7;
      transition: opacity .3s ease, transform .3s ease;
      pointer-events:none;
    }
    .scroll-hint[data-hidden="true"]{
      opacity:0;
      transform: translateY(10px);
    }
    .scroll-hint-icon{
      font-size:1rem;
      line-height:1;
      animation: scroll-hint-bob 2.4s ease-in-out infinite;
    }
    @keyframes scroll-hint-bob{
      0%,100%{ transform: translateY(0); opacity:.6; }
      50%{ transform: translateY(4px); opacity:1; }
    }

    /* ====== Dimensional background canvas ====== */
    #networkCanvas{
      position:fixed;
      inset:0;
      z-index:-2;
      pointer-events:none;
      filter: blur(1px);
      mix-blend-mode:screen;
      opacity:0;
      transition: opacity 1.8s ease;
    }
    body[data-phase="intro"] #networkCanvas{ opacity:0; }

    /* ====== Intro overlay ====== */
    #intro-overlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(circle at 50% 40%, rgba(18,22,28,.6), rgba(8,10,14,.92));
      z-index:20;
      pointer-events:none;
      transition: opacity 1s ease;
    }
    #intro-overlay::after{
      content:"";
      position:absolute;
      inset:10%;
      border:1px solid rgba(157,178,191,.08);
      pointer-events:none; 
      mix-blend-mode:screen;
    }
    #intro-overlay h1{
      font-size: clamp(2.4rem, 8vw, 5.2rem);
      letter-spacing:.38em;
      font-weight:500;
      margin:0;
      text-transform:uppercase;
      color: color-mix(in oklab, var(--accent-4) 45%, var(--text));
      text-shadow:0 0 60px rgba(157,178,191,.15);
    }
    body[data-phase="revealed"] #intro-overlay{ opacity:0; pointer-events:none; }
    body[data-phase="revealed"] main,
    body[data-phase="revealed"] footer{ opacity:1; }
    body[data-phase="intro"] main,
    body[data-phase="intro"] footer{ opacity:0; }

    main, footer{ transition: opacity 1.35s ease .5s; }

    @media (prefers-reduced-motion: reduce){
      #networkCanvas{ display:none; }
      #intro-overlay{ transition:none; }
      header, .hero, main, footer{ transition:none; }
    }
  </style>
</head>
<body data-phase="intro">
  <canvas id="networkCanvas" aria-hidden="true"></canvas>
  <div id="intro-overlay" role="presentation">
    <h1>ONONO</h1>
  </div>
  <a class="skip" href="#content">Skip to content</a>
  <noscript>
    <style>
      body[data-phase="intro"] #intro-overlay{display:none;}
      body[data-phase="intro"] header{opacity:1; transform:none;}
      body[data-phase="intro"] .hero{opacity:1; transform:none;}
      body[data-phase="intro"] main,
      body[data-phase="intro"] footer{opacity:1;}
    </style>
  </noscript>

  <!-- ====== Header / Nav ====== -->
  <header>
    <nav class="nav container" aria-label="Primary">
      <div class="brand" aria-label="ONONO">ONONO</div>
      <div class="nav-links">
        <a href="#thesis">Thesis</a>
        <a href="#company">Company</a>
        <a href="#allies">Allies</a>
      </div>
    </nav>
  </header>

  <main id="content">
    <!-- ====== Hero ====== -->
    <section id="home" class="hero">
      <div class="container center">
        <span class="kicker">Stealth mode · Innovation-First</span>
        <h1>From <span class="hero-word" data-hero-word aria-live="polite">UNDERSTANDING</span><br />to Intelligence.</h1>
        <p class="lead">
          We believe the mainstream AI path is misaligned with reality. The world is complex and shifting;
          more data or longer memory alone do not yield truth, understanding, or better decisions.
        </p>
        <div class="hero-motto">
          <span class="hero-motto-line" data-hero-motto>Don’t accept the usual.</span>
          <span>Resist.</span>
        </div>
        <div class="sigil" aria-hidden="true">
          <span class="sigil-ring"></span>
          <span class="sigil-glyph">∴</span>
        </div>
      </div>
    </section>

    <!-- ====== Vision / Thesis ====== -->
    <section id="thesis" class="hairline">
      <div class="container stack">
        <div class="kicker">Thesis</div>
        <div class="panel stack">
          <p class="muted" style="margin:0; max-width:var(--maxw)">
            The prevailing belief that bigger datasets, larger knowledge bases, or superior memory
            will solve intelligence is, in our view, incomplete.
          </p>
          <ul class="thesis-points">
            <li>The world is non‑stationary, complex, and often not learnable from data alone.</li>
            <li>Knowing more does not guarantee better decisions.</li>
            <li>Data ≠ understanding. Memory ≠ intelligence.</li>
            <li>Systems centered on data/knowledge/memory alone struggle under real‑world volatility.</li>
          </ul>
          <p class="muted" style="margin:0; max-width:var(--maxw)">
            ONONO explores multi‑dimensional cognitive approaches aimed at meeting a rapidly changing external reality
            through ongoing thinking and understanding. We are in stealth and presently focused on internal research.
          </p>
          <p class="muted" style="margin:0; max-width:var(--maxw)">
            ONONO stands for Overlapping Networks of Nested Ontologies—an AI cognitive system capable of reconstructing
            complex worlds, based on multi-dimensional semantic networks that flex and recombine.
          </p>
          <p class="muted" style="margin:0; max-width:var(--maxw)">
            Natural language is a key to human-level intelligence: knowledge, experience, and understanding are
            multi-dimensional and, within recursive systems, mapped into language-based segments that assemble into
            intricate, living networks. Computation is the substrate of the world—unceasing, omnipresent. Cognition
            emerges from information-preserving, self-iterating processing networks; their instantaneous configuration is
            what we call consciousness.
          </p>
        </div>
      </div>
    </section>

    <!-- ====== Company ====== -->
    <section id="company" class="hairline" aria-labelledby="company-title">
      <div class="container stack">
        <div class="kicker" id="company-title">Company</div>
        <div class="panel center">
          <p class="muted" style="max-width:var(--maxw); margin:0">
            Founded in 2025, ONONO is a Europe-based team operating in the space between pre-seed and seed. We maintain a calm,
            private posture while we refine the system.
          </p>
          <p class="muted small" style="margin:0">Signal over noise. Fewer words, deeper work.</p>
        </div>
      </div>
    </section>

    <!-- ====== Allies (Investors · Team · Partners) ====== -->
    <section id="allies" class="hairline" aria-labelledby="allies-title">
      <div class="container stack">
        <div class="kicker" id="allies-title">Allies</div>
        <div class="panel stack">
          <p class="muted" style="margin:0; max-width:var(--maxw)">
            We favor investors, team members, and partners with long-term vision and a distinct understanding of
            intelligence. Materials stay within deliberate, one-to-one conversations.
          </p>
          <div class="divider" aria-hidden="true"></div>
          <div class="stack" style="gap:16px">
            <div>
              <div class="caps">Investors</div>
              <p class="muted" style="margin:.3rem 0 0; max-width:var(--maxw)">
                Quiet exchanges only. Reach out for a signal when the time feels aligned.
              </p>
              <div class="cta">
               <a class="btn" href="mailto:hello@onono.ai?subject=Investor%20Conversation%20with%20ONONO&body=Hi%20ONONO%20Team%2C%0A%0AI%27m%20curious%20about%20your%20project%20and%20would%20love%20to%20hear%20more.%0A%0ANo%20buzzwords%2C%20no%20hype%20metrics%20%E2%80%94%20just%20a%20real%20conversation.%0A%0ALooking%20forward%20to%20connecting.%0A%0ABest%2C%0A%5BYour%20Name%5D">
  <span style="font-size:1.2em; margin-right:6px;">✉️</span> Curious about ONONO
</a>
              </div>
            </div>
            <div class="divider" aria-hidden="true"></div>
            <div>
              <div class="caps">Hiring</div>
              <h3 style="margin:.3rem 0 0; font-size: clamp(1.2rem, 2.6vw, 1.6rem); letter-spacing:-.01em;">Senior Full‑Stack TypeScript Developer</h3>
              <p class="muted" style="margin:.3rem 0 0; max-width:var(--maxw)">
                We assemble a senior, minimal team. Process: measured task · technical dialogue · values alignment.
              </p>
              <div class="cta">
               <a class="btn" href="mailto:hello@onono.ai?subject=Application%20%E2%80%94%20Senior%20Full-Stack%20TypeScript%20Developer&body=Hi%20ONONO%20Team%2C%0A%0AI%27m%20interested%20in%20the%20Senior%20Full-Stack%20TypeScript%20Developer%20role.%0A%0AHere%27s%20a%20bit%20about%20me%3A%0A- Background%20%2F%20experience%3A%20%5Byour%20summary%5D%0A- Projects%20I%27m%20proud%20of%3A%20%5Blinks%20or%20short%20note%5D%0A- Why%20ONONO%3F%20%5Byour%20reason%5D%0A%0ALooking%20forward%20to%20hearing%20from%20you.%0A%0ABest%2C%0A%5BYour%20Name%5D">
  <span style="font-size:1.2em; margin-right:6px;">✉️</span> Apply to ONONO
</a>
              </div>
            </div>
            <div class="divider" aria-hidden="true"></div>
            <div>
              <div class="caps">Partners</div>
              <p class="muted" style="margin:.3rem 0 0; max-width:var(--maxw)">
                For select collaborations that reinforce the thesis and extend our reach into complex environments.
              </p>
              <div class="cta">
                <a class="btn btn-ghost" href="mailto:hello@onono.ai?subject=Partnership%20Inquiry%20with%20ONONO&body=Hi%20ONONO%20Team%2C%0A%0AI%27m%20reaching%20out%20about%20a%20possible%20partnership.%0A%0AMy%20organization%3A%20%5Byour%20company%2Fteam%20name%5D%0AWhat%20we%20do%3A%20%5Bshort%20description%5D%0AWhat%20I%27m%20curious%20about%20with%20ONONO%3A%20%5Bone%20line%5D%0A%0ALooking%20forward%20to%20your%20thoughts.%0A%0ABest%2C%0A%5BYour%20Name%5D">
  <span style="font-size:1.2em; margin-right:6px;">✉️</span> Partnership with ONONO
</a>

              </div>
            </div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <!-- ====== Footer ====== -->
  <footer>
    <div class="container footgrid small">
      <div>© <span class="mono">2025</span> ONONO</div>
      <div class="nav-links">
        <span>Privacy: We don’t bake cookies. Keep us in mind, not the other way around.</span>
      </div>
    </div>
  </footer>

  <div class="scroll-hint" data-scroll-hint aria-hidden="true">
    <span class="scroll-hint-text">Scroll</span>
    <span class="scroll-hint-icon">⌄</span>
  </div>

  <script>
    (function(){
      const randRange = (min, max) => Math.random() * (max - min) + min;
      const BASE_MIN = 3000;
      const BASE_MAX = 5000;
      const EXTRA_HOLD = 2000;
      const FIRST_MULTIPLIER = 2.5;
      const FIRST_RANGE = [BASE_MIN * FIRST_MULTIPLIER, BASE_MAX * FIRST_MULTIPLIER];
      const REGULAR_RANGE = [BASE_MIN + EXTRA_HOLD, BASE_MAX + EXTRA_HOLD];

      const heroWordContainer = document.querySelector('[data-hero-word]');
      const sigilEl = document.querySelector('.sigil');
      const sigilRing = document.querySelector('.sigil-ring');
      if (heroWordContainer) {
        const rawHeroOptions = [
          'Meaning', 'Interpretation', 'Explanation', 'Knowledge', 'Awareness', 'Consciousness', 'Perception', 'Insight',
          'Reflection', 'Reason', 'Thought', 'Comprehension', 'Cognition', 'Experience', 'Perspective', 'Narrative', 'Context',
          'Sense-making', 'Abstraction', 'Concept', 'Wisdom'
        ];
        const baseWord = (heroWordContainer.textContent || 'UNDERSTANDING').trim().toUpperCase();
        const heroWordOptions = Array.from(new Set(rawHeroOptions.map(word => word.trim().toUpperCase()).filter(Boolean)));
        if (!heroWordOptions.includes(baseWord)) {
          heroWordOptions.push(baseWord);
        }

        heroWordContainer.setAttribute('aria-atomic', 'true');
        const staticEl = document.createElement('span');
        staticEl.className = 'word-static';
        staticEl.textContent = baseWord;
        heroWordContainer.textContent = '';
        heroWordContainer.appendChild(staticEl);

        let currentWord = baseWord;
        let heroTimer = null;
        let heroWaitingForVisibility = false;
        let heroUseFirstRange = true;

        const scheduleHeroWord = () => {
          clearTimeout(heroTimer);
          const [min, max] = heroUseFirstRange ? FIRST_RANGE : REGULAR_RANGE;
          heroUseFirstRange = false;
          heroTimer = window.setTimeout(() => {
            heroTimer = null;
            if (document.hidden) {
              heroWaitingForVisibility = true;
              return;
            }
            changeHeroWord();
          }, randRange(min, max));
        };

        const changeHeroWord = () => {
          const candidates = heroWordOptions.filter(word => word !== currentWord);
          if (!candidates.length) {
            scheduleHeroWord();
            return;
          }
          const nextWord = candidates[Math.floor(Math.random() * candidates.length)];
          staticEl.classList.add('is-fading-out');
          window.setTimeout(() => {
            staticEl.textContent = nextWord;
            staticEl.classList.remove('is-fading-out');
            staticEl.classList.add('is-fading-in');
            window.setTimeout(() => {
              staticEl.classList.remove('is-fading-in');
            }, 360);
          }, 200);
          currentWord = nextWord;
          scheduleHeroWord();
        };

        scheduleHeroWord();

        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            clearTimeout(heroTimer);
            heroTimer = null;
            heroWaitingForVisibility = true;
          } else if (heroWaitingForVisibility || heroTimer === null) {
            heroWaitingForVisibility = false;
            scheduleHeroWord();
          }
        });
      }

      const heroMottoLine = document.querySelector('[data-hero-motto]');
      if (heroMottoLine) {
        const mottoOptions = [
          "Don’t accept the usual.",
          "Don’t follow the crowd.",
          "Don’t chase the mainstream.",
          "Don’t be ruled by habit.",
          "Don’t be led by noise.",
          "Don’t follow hype.",
          "Don’t let the loudest lead.",
          "Don’t fetishize benchmarks."
        ].map(text => text.trim()).filter(Boolean);
        const basePhrase = (heroMottoLine.textContent || mottoOptions[0]).trim();
        if (!mottoOptions.includes(basePhrase)) {
          mottoOptions.push(basePhrase);
        }

        heroMottoLine.setAttribute('aria-live', 'polite');
        heroMottoLine.setAttribute('aria-atomic', 'true');

        let currentPhrase = basePhrase;
        let mottoTimer = null;
        let mottoWaitingForVisibility = false;
        let mottoUseFirstRange = true;

        const scheduleMotto = () => {
          clearTimeout(mottoTimer);
          const [min, max] = mottoUseFirstRange ? FIRST_RANGE : REGULAR_RANGE;
          mottoUseFirstRange = false;
          mottoTimer = window.setTimeout(() => {
            mottoTimer = null;
            if (document.hidden) {
              mottoWaitingForVisibility = true;
              return;
            }
            changeMottoPhrase();
          }, randRange(min, max));
        };

        const changeMottoPhrase = () => {
          const candidates = mottoOptions.filter(phrase => phrase !== currentPhrase);
          if (!candidates.length) {
            scheduleMotto();
            return;
          }
          const nextPhrase = candidates[Math.floor(Math.random() * candidates.length)];
          heroMottoLine.classList.add('is-fading-out');
          window.setTimeout(() => {
            heroMottoLine.textContent = nextPhrase;
            heroMottoLine.classList.remove('is-fading-out');
            heroMottoLine.classList.add('is-fading-in');
            window.setTimeout(() => {
              heroMottoLine.classList.remove('is-fading-in');
            }, 360);
          }, 200);
          currentPhrase = nextPhrase;
          scheduleMotto();
        };

        scheduleMotto();

        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            clearTimeout(mottoTimer);
            mottoTimer = null;
            mottoWaitingForVisibility = true;
          } else if (mottoWaitingForVisibility || mottoTimer === null) {
            mottoWaitingForVisibility = false;
            scheduleMotto();
          }
        });
      }

      const scrollHint = document.querySelector('[data-scroll-hint]');
      if (scrollHint) {
        const updateScrollHint = () => {
          const scrollTop = window.scrollY || document.documentElement.scrollTop || 0;
          const viewportHeight = window.innerHeight || document.documentElement.clientHeight || 0;
          const scrollHeight = document.documentElement.scrollHeight || document.body.scrollHeight || 0;
          const atBottom = scrollTop + viewportHeight >= scrollHeight - 4;
          const isScrollable = scrollHeight > viewportHeight + 4;
          scrollHint.dataset.hidden = (!isScrollable || atBottom) ? 'true' : 'false';
        };

        updateScrollHint();
        document.addEventListener('scroll', updateScrollHint, { passive: true });
        window.addEventListener('resize', updateScrollHint);
        document.addEventListener('visibilitychange', () => {
          if (!document.hidden) {
            updateScrollHint();
          }
        });
      }
      const body = document.body;
      const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');
      if (motionQuery.matches) {
        body.dataset.phase = 'revealed';
        return;
      }

      const introStart = performance.now();
      const INTRO_MIN = 2200;
      const AUTO_REVEAL = 3200;

      const finishReveal = () => {
        if (body.dataset.phase !== 'revealed') {
          body.dataset.phase = 'revealed';
          document.removeEventListener('scroll', requestReveal);
        }
      };

      const requestReveal = () => {
        if (body.dataset.phase === 'revealed') return;
        const elapsed = performance.now() - introStart;
        const wait = Math.max(0, INTRO_MIN - elapsed);
        if (wait > 0) {
          setTimeout(finishReveal, wait);
        } else {
          finishReveal();
        }
        window.removeEventListener('pointerdown', requestReveal);
        window.removeEventListener('keydown', requestReveal);
      };

      setTimeout(requestReveal, AUTO_REVEAL);
      document.addEventListener('scroll', requestReveal, { passive: true, once: true });
      window.addEventListener('pointerdown', requestReveal, { once: true });
      window.addEventListener('keydown', requestReveal, { once: true });

      const canvas = document.getElementById('networkCanvas');
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext('2d');
      const keywords = `time, temporality, event, events, history, causality, narrative, story, sequence, chain of evidence, perspective, multi-perspective, intersubjectivity, subjectivity, viewpoint, voice, discourse, meaning, interpretation, understanding, explanation, knowledge, memory, data, information, computation, process, relation, relationships, connection, link, mapping, structure, pattern, category, abstraction, generalization, metaphor, symbol, language, words, concepts, ontology, nested ontologies, overlapping networks, networks, graph, web, system, dynamics, change, transformation, evolution, emergence, complexity, uncertainty, volatility, openness, context, world, reality, representation, model, surface, essence, appearance, nature, substance, form, difference, similarity, contrast, identity, otherness, boundary, limit, horizon, possibility, potential, hypothesis, assumption, evaluation, testing, critique, reflection, recursion, iteration, self-reference, feedback, loop, correlation, autocorrelation, autoregression, induction, deduction, abduction, analysis, synthesis, statistics, probability, inference, reason, logic, causation, consequence, choice, decision, judgment, agency, action, tool, instrument, construction, recombination, composition, innovation, creativity, imagination, discovery, invention, novelty, intuition, consciousness, awareness, presence, emergence, essence, meaning-making, interpretation, hermeneutics, phenomenology, epistemology, ontology, ethics, responsibility, trust, alignment, cooperation, dialogue, communication, interrelation, interaction, resonance, coherence, continuity, disruption, fragmentation, wholeness, totality, plurality, diversity, unity, paradox, ambiguity, uncertainty, openness, possibility, potentiality, transcendence`.split(',').map(k => k.trim());

      const viewportWidth = window.innerWidth || document.documentElement.clientWidth || 0;
      const baseNodeCount = 78;
      const densityFactor = viewportWidth < 640 ? 0.58 : viewportWidth < 1024 ? 0.78 : 1;
      const rawPixelRatio = window.devicePixelRatio || 1;
      const ratioFactor = rawPixelRatio > 1.5 ? 0.9 : 1;
      const MAX_PIXEL_RATIO = 1.8;
      const NODE_COUNT = Math.max(36, Math.round(baseNodeCount * densityFactor * ratioFactor));
      const NEAREST_TARGET = 2;
      const rand = (min, max) => Math.random() * (max - min) + min;
      const BASE_EDGE_COLORS = [
        [190, 220, 240],
        [120, 160, 210],
        [40, 80, 140]
      ];
      const BASE_TEXT_COLOR = [210, 220, 230];
      const BASE_SHADOW_COLOR = [190, 210, 240];
      const EDGE_TINT_LIGHTNESS = [0.78, 0.64, 0.48];
      const TEXT_TINT_LIGHTNESS = 0.82;
      const SHADOW_TINT_LIGHTNESS = 0.76;
      const clampColor = (value) => Math.max(0, Math.min(255, value));
      const mixColors = (base, tint, amount) => {
        const factor = Math.max(0, amount);
        return [
          clampColor(base[0] + (tint[0] - base[0]) * factor),
          clampColor(base[1] + (tint[1] - base[1]) * factor),
          clampColor(base[2] + (tint[2] - base[2]) * factor)
        ];
      };
      const hslToRgb = (h, s, l) => {
        const hue = ((h % 360) + 360) % 360 / 360;
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        const channel = (t) => {
          let temp = t;
          if (temp < 0) temp += 1;
          if (temp > 1) temp -= 1;
          if (temp < 1 / 6) return p + (q - p) * 6 * temp;
          if (temp < 1 / 2) return q;
          if (temp < 2 / 3) return p + (q - p) * (2 / 3 - temp) * 6;
          return p;
        };
        return [channel(hue + 1 / 3) * 255, channel(hue) * 255, channel(hue - 1 / 3) * 255];
      };
      const toRgba = (rgb, alpha) => `rgba(${Math.round(rgb[0])}, ${Math.round(rgb[1])}, ${Math.round(rgb[2])}, ${alpha})`;
      const state = {
        nodes: [],
        mouse: { speed: 0 },
        pointer: { x: 0.5, y: 0.5, active: false, polarity: 1, radius: 0.16, lastMove: 0 },
        visibility: 0,
        targetVisibility: 0,
        boost: {
          hold: false,
          releaseAt: 0,
          multiplier: 1,
          target: 1,
          colorIntensity: 0,
          hue: 210,
          saturation: 0.25
        }
      };

      const schedule = {
        start: performance.now() + rand(3000, 7000),
        nextPulse: Infinity,
        pulseEnd: -1
      };

      const schedulePulse = (from) => {
        schedule.nextPulse = from + rand(3000, 8000);
        schedule.pulseEnd = schedule.nextPulse + rand(1000, 3000);
      };
      schedulePulse(schedule.start);

      function resize() {
        const ratio = Math.min(window.devicePixelRatio || 1, MAX_PIXEL_RATIO);
        canvas.width = window.innerWidth * ratio;
        canvas.height = window.innerHeight * ratio;
        ctx.setTransform(ratio, 0, 0, ratio, 0, 0);
      }
      resize();
      window.addEventListener('resize', resize);

      function createNode(index) {
        const now = performance.now();
        return {
          x: Math.random(),
          y: Math.random(),
          z: Math.random(),
          vx: rand(-0.00028, 0.00028),
          vy: rand(-0.00028, 0.00028),
          drift: rand(0.12, 0.55),
          phase: rand(0, Math.PI * 2),
          wobble: rand(0.18, 0.65),
          word: keywords[Math.floor(Math.random() * keywords.length)],
          swapAt: now + rand(6000, 20000),
          randomLink: null,
          randomLink2: null,
          wantsSecondLink: Math.random() < 0.45,
          randomLinkExpiry: now + rand(4000, 9000),
          randomLink2Expiry: now + rand(6000, 12000),
          shimmer: 0,
          pointerGlow: 0,
          pointerShade: 0,
          pulseAt: now + rand(4000, 13000),
          speedBias: rand(0.65, 1.15),
          speedPhase: rand(0, Math.PI * 2)
        };
      }

      for (let i = 0; i < NODE_COUNT; i++) {
        state.nodes.push(createNode(i));
      }
      for (let i = 0; i < NODE_COUNT; i++) {
        const node = state.nodes[i];
        node.randomLink = Math.floor(Math.random() * NODE_COUNT);
        if (node.randomLink === i) node.randomLink = (node.randomLink + 7) % NODE_COUNT;
        if (node.wantsSecondLink) {
          node.randomLink2 = Math.floor(Math.random() * NODE_COUNT);
          if (node.randomLink2 === i || node.randomLink2 === node.randomLink) {
            node.randomLink2 = (node.randomLink2 + 13) % NODE_COUNT;
          }
        }
      }

      let lastTime = performance.now();
      let noiseSeed = rand(0, 1000);
      const maxSpeed = 1000;
      let sigilWasBoosting = false;

      function update(now) {
        const dt = Math.min((now - lastTime) / 16, 4);
        lastTime = now;

        const ratio = Math.min(window.devicePixelRatio || 1, MAX_PIXEL_RATIO);
        const width = canvas.width / ratio;
        const height = canvas.height / ratio;
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const boostActive = state.boost.hold || now <= state.boost.releaseAt;
        state.boost.target = boostActive ? 1.8 : 1;
        state.boost.multiplier += (state.boost.target - state.boost.multiplier) * 0.08;
        const colorTarget = boostActive ? 2 : 0;
        state.boost.colorIntensity += (colorTarget - state.boost.colorIntensity) * 0.08;
        if (sigilEl && sigilWasBoosting !== boostActive) {
          sigilEl.dataset.boosting = boostActive ? 'true' : 'false';
          sigilWasBoosting = boostActive;
        }

        if (now >= schedule.start) {
          if (schedule.nextPulse === Infinity) {
            schedulePulse(now);
          }
          if (now >= schedule.nextPulse && now <= schedule.pulseEnd) {
            state.targetVisibility = 0.55;
          } else {
            state.targetVisibility = 0.04;
            if (now > schedule.pulseEnd) {
              schedulePulse(now);
            }
          }
        } else {
          state.targetVisibility = 0;
        }

        state.visibility += (state.targetVisibility - state.visibility) * 0.04;
        const visibleOpacity = now >= schedule.start ? 0.02 + state.visibility * 0.85 : 0;
        canvas.style.opacity = visibleOpacity.toFixed(3);

        const motionFactor = (0.55 + Math.min(state.mouse.speed / maxSpeed, 0.9)) * state.boost.multiplier;
        const pointer = state.pointer;

        ctx.save();
        ctx.translate(0.5, 0.5);

        if (pointer.active && now - pointer.lastMove > 480) {
          pointer.active = false;
        }

        const mobileFontFactor = width < 680 ? 0.7 : 1;
        const fontBase = (width < 520 ? 7.2 : width < 768 ? 8.4 : width < 1024 ? 9.2 : 10) * mobileFontFactor;
        const fontRange = (width < 520 ? 18 : width < 768 ? 21 : width < 1024 ? 24 : 26) * mobileFontFactor;
        const blurBase = width < 520 ? 10 : width < 768 ? 14 : 18;
        const blurRange = width < 520 ? 26 : width < 768 ? 34 : 42;

        const tintHue = state.boost.hue;
        const tintSaturation = state.boost.saturation;
        const tintAmount = Math.min(state.boost.colorIntensity * 0.65, 1.3);
        const tintedEdges = BASE_EDGE_COLORS.map((base, idx) => {
          const tint = hslToRgb(tintHue, tintSaturation, EDGE_TINT_LIGHTNESS[idx]);
          return mixColors(base, tint, tintAmount);
        });
        const tintedText = mixColors(BASE_TEXT_COLOR, hslToRgb(tintHue, tintSaturation, TEXT_TINT_LIGHTNESS), tintAmount);
        const tintedShadow = mixColors(BASE_SHADOW_COLOR, hslToRgb(tintHue, tintSaturation, SHADOW_TINT_LIGHTNESS), tintAmount);

        for (let i = 0; i < state.nodes.length; i++) {
          const node = state.nodes[i];
          node.phase += 0.0019 * dt * node.drift * (0.7 + motionFactor * 0.35);
          const variability = node.speedBias + Math.sin(now / 2000 + node.speedPhase) * 0.25;
          const speed = (0.32 + motionFactor * 0.45) * variability;
          node.x += (node.vx * 0.8 + Math.sin(node.phase + noiseSeed) * 0.00035 * node.wobble) * dt * speed;
          node.y += (node.vy * 0.8 + Math.cos(node.phase - noiseSeed) * 0.00035 * node.wobble) * dt * speed;
          node.z += Math.sin(now / 1400 + node.phase * 1.4) * 0.0005 * dt;
          node.z = Math.min(0.95, Math.max(0.05, node.z));

          if (node.x < -0.12) node.x = 1.12;
          if (node.x > 1.12) node.x = -0.12;
          if (node.y < -0.12) node.y = 1.12;
          if (node.y > 1.12) node.y = -0.12;

          if (now > node.swapAt) {
            node.word = keywords[Math.floor(Math.random() * keywords.length)];
            node.swapAt = now + rand(8000, 26000);
          }
          if (now > node.randomLinkExpiry) {
            node.randomLinkExpiry = now + rand(6000, 13000);
            let idx = Math.floor(Math.random() * NODE_COUNT);
            if (idx === i) idx = (idx + 9) % NODE_COUNT;
            node.randomLink = idx;
          }
          if (node.wantsSecondLink && now > node.randomLink2Expiry) {
            node.randomLink2Expiry = now + rand(8000, 16000);
            let idx = Math.floor(Math.random() * NODE_COUNT);
            if (idx === i || idx === node.randomLink) idx = (idx + 11) % NODE_COUNT;
            node.randomLink2 = idx;
          } else if (!node.wantsSecondLink) {
            node.randomLink2 = null;
          }

          if (now > node.pulseAt) {
            node.shimmer = 1.2;
            node.pulseAt = now + rand(6000, 14000);
          }
          node.shimmer *= 0.94;
          node.pointerGlow *= 0.88;
          node.pointerShade *= 0.88;

          if (pointer.active) {
            const dx = pointer.x - node.x;
            const dy = pointer.y - node.y;
            const dist = Math.hypot(dx, dy);
            if (dist < pointer.radius) {
              const influence = 1 - dist / pointer.radius;
              if (pointer.polarity > 0) {
                node.pointerGlow = Math.min(1.4, node.pointerGlow + influence * (0.4 + Math.random() * 0.2));
              } else {
                node.pointerShade = Math.min(1.2, node.pointerShade + influence * (0.35 + Math.random() * 0.25));
              }
            }
          }
        }

        for (let i = 0; i < state.nodes.length; i++) {
          const a = state.nodes[i];
          const ax = a.x * width;
          const ay = a.y * height;

          const nearest = Array.from({ length: NEAREST_TARGET }, () => ({ dist: Infinity, index: -1 }));

          for (let j = 0; j < state.nodes.length; j++) {
            if (i === j) continue;
            const b = state.nodes[j];
            const dx = ax - b.x * width;
            const dy = ay - b.y * height;
            const dist = dx * dx + dy * dy;
            if (dist < nearest[0].dist) {
              if (nearest.length > 1) nearest[1] = nearest[0];
              nearest[0] = { dist, index: j };
            } else if (nearest.length > 1 && dist < nearest[1].dist) {
              nearest[1] = { dist, index: j };
            }
          }

          const neighborIndices = new Set();
          nearest.forEach(n => { if (n.index !== -1) neighborIndices.add(n.index); });
          if (a.randomLink !== null) neighborIndices.add(a.randomLink);
          if (a.randomLink2 !== null) neighborIndices.add(a.randomLink2);

          const neighbors = Array.from(neighborIndices).map(idx => state.nodes[idx]);
          const depthAlpha = (1 - a.z) * 0.45 + a.shimmer * 0.3;
          const pointerLift = (a.pointerGlow - a.pointerShade) * 0.35;

          for (const n of neighbors) {
            const bx = n.x * width;
            const by = n.y * height;
            const partnerAlpha = (1 - n.z) * 0.4 + n.shimmer * 0.25;
            const partnerPointer = (n.pointerGlow - n.pointerShade) * 0.35;
            const edgeAlpha = Math.max(0.05, Math.min(0.75, (depthAlpha + partnerAlpha) * 0.5 + pointerLift + partnerPointer));
            const gradient = ctx.createLinearGradient(ax, ay, bx, by);
            gradient.addColorStop(0, toRgba(tintedEdges[0], edgeAlpha));
            gradient.addColorStop(0.6, toRgba(tintedEdges[1], edgeAlpha * 0.75));
            gradient.addColorStop(1, toRgba(tintedEdges[2], Math.max(0.05, edgeAlpha * 0.6)));
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 0.35 + (1 - a.z) * 1.25 + a.pointerGlow * 0.35;
            ctx.globalAlpha = Math.min(1, 0.6 + state.visibility * 0.8);
            ctx.beginPath();
            ctx.moveTo(ax, ay);
            ctx.lineTo(bx, by);
            ctx.stroke();
          }
        }

        ctx.globalAlpha = 1;

        for (const node of state.nodes) {
          const size = fontBase + (1 - node.z) * fontRange;
          const visibilityBoost = Math.min(1, state.visibility + 0.1);
          const glow = node.pointerGlow;
          const shade = node.pointerShade;
          const alpha = Math.max(0.04, Math.min(0.5, (0.05 + (1 - node.z) * 0.22 + node.shimmer * 0.35 + glow * 0.4 - shade * 0.4) * visibilityBoost));
          const x = node.x * width;
          const y = node.y * height;
          ctx.save();
          ctx.translate(x, y);
          ctx.globalAlpha = alpha;
          ctx.fillStyle = toRgba(tintedText, 1);
          ctx.font = `${size}px "IBM Plex Mono", "SFMono-Regular", monospace`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.shadowColor = toRgba(tintedShadow, 0.25 + glow * 0.4);
          ctx.shadowBlur = blurBase + (1 - node.z) * blurRange + glow * 24;
          ctx.fillText(node.word, 0, 0);
          ctx.restore();
        }

        ctx.restore();

        state.mouse.speed *= 0.92;
        noiseSeed += 0.00022 * (0.6 + state.visibility * 0.8) * state.boost.multiplier;

        requestAnimationFrame(update);
      }
      requestAnimationFrame(update);

      let lastMouseTime = performance.now();
      let lastMouseX = null;
      let lastMouseY = null;
      function pointerMove(e) {
        const now = performance.now();
        const { clientX: x, clientY: y } = e;
        const width = window.innerWidth;
        const height = window.innerHeight;
        state.pointer.x = x / width;
        state.pointer.y = y / height;
        state.pointer.active = true;
        state.pointer.lastMove = now;
        state.pointer.polarity = Math.random() > 0.5 ? 1 : -1;
        state.pointer.radius = rand(0.12, 0.2);

        if (lastMouseX != null) {
          const dx = x - lastMouseX;
          const dy = y - lastMouseY;
          const dt = now - lastMouseTime || 16;
          const distance = Math.hypot(dx, dy);
          const speed = distance / dt * 1000;
          state.mouse.speed = Math.min(maxSpeed, state.mouse.speed * 0.6 + speed * 0.4 + Math.random() * 30);
        }
        lastMouseX = x;
        lastMouseY = y;
        lastMouseTime = now;
      }

      window.addEventListener('pointermove', pointerMove, { passive: true });
      window.addEventListener('pointerleave', () => {
        lastMouseX = null;
        lastMouseY = null;
        state.pointer.active = false;
      });

      if (sigilRing) {
        const boostState = state.boost;
        let releaseTimer = null;
        const clearReleaseTimer = () => {
          if (releaseTimer) {
            window.clearTimeout(releaseTimer);
            releaseTimer = null;
          }
        };
        const scheduleRelease = () => {
          boostState.releaseAt = performance.now() + 250;
          clearReleaseTimer();
          releaseTimer = window.setTimeout(() => {
            releaseTimer = null;
          }, 260);
        };
        const setNewTint = () => {
          boostState.hue = Math.random() * 360;
          boostState.saturation = 0.35 + Math.random() * 0.25;
        };
        const onPointerDown = (event) => {
          if (!sigilRing.contains(event.target)) return;
          try { sigilRing.setPointerCapture(event.pointerId); } catch (err) { /* no-op */ }
          boostState.hold = true;
          boostState.releaseAt = performance.now() + 500;
          setNewTint();
          clearReleaseTimer();
        };
        const onPointerUp = () => {
          boostState.hold = false;
          scheduleRelease();
        };
        sigilRing.addEventListener('pointerdown', onPointerDown);
        sigilRing.addEventListener('pointerup', onPointerUp);
        sigilRing.addEventListener('pointercancel', onPointerUp);
        sigilRing.addEventListener('pointerleave', (event) => {
          if (event.buttons) {
            return;
          }
          boostState.hold = false;
        });
        sigilRing.addEventListener('click', (event) => {
          event.preventDefault();
          boostState.hold = false;
          scheduleRelease();
        });
      }

      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          state.mouse.speed = 0;
          state.pointer.active = false;
          state.boost.hold = false;
          state.boost.releaseAt = 0;
        }
      });
    })();
  </script>

</body>
</html>
